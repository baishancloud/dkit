
import hashlib
import os
import threading
import types

from kazoo import security

from pykit import config
from pykit import net

PERM_TO_LONG = {
    'c': 'create',
    'd': 'delete',
    'r': 'read',
    'w': 'write',
    'a': 'admin',
}

PERM_TO_SHORT = {
    'create': 'c',
    'delete': 'd',
    'read': 'r',
    'write': 'w',
    'admin': 'a',
}

# We assumes that ip does not change during process running.
# Display intra ip if presents, or display pub ip.
host_ip4 = net.ips_prefer(net.get_host_ip4(), net.INN)


class PermTypeError(Exception):
    pass


counter = {'n': 0, 'lock': threading.RLock()}


def _incr():

    with counter['lock']:
        counter['n'] += 1
        return counter['n']


def lock_data(node_id=None):
    # deprecated
    return lock_id(node_id=node_id)


def lock_id(node_id=None):
    """
    Embed lock holder information into the zk node data for the lock.

    `node_id` is a user defined identifier of a host.
    """

    if node_id is None:
        node_id = config.zk_node_id

    ip = (host_ip4 + ['unknownip'])[0]

    seq = [node_id, ip, str(os.getpid()), '{c:0>10}'.format(c=_incr())]

    return '-'.join(seq)


def parse_lock_data(data_str):
    # deprecated
    return parse_lock_id(data_str)


def parse_lock_id(data_str):
    """
    Parse string generated by lock_id()
    """

    node_id, ip, process_id, cnt = (data_str.split('-', 3) + ([None] * 4))[:4]

    if type(process_id) in types.StringTypes and process_id.isdigit():
        process_id = int(process_id)
    else:
        process_id = None

    rst = {
        'node_id': node_id,
        'ip': ip,
        'process_id': process_id,
        'counter': cnt,
        'txid': None
    }

    if node_id.startswith('txid:'):
        rst['txid'] = node_id.split(':', 1)[1]

    return rst


def make_digest(acc):
    # acc = "username:password"

    digest = hashlib.sha1(acc).digest().encode('base64').strip()
    return digest


def make_acl_entry(username, password, permissions):

    perms = ''
    for c in permissions:
        if c not in PERM_TO_LONG:
            raise PermTypeError(c)
        perms += c

    return "digest:{username}:{digest}:{permissions}".format(
        username=username,
        digest=make_digest(username + ":" + password),
        permissions=perms)


def perm_to_long(short, lower=True):

    rst = []

    for c in short:
        c = c.lower()
        if c not in PERM_TO_LONG:
            raise PermTypeError(c)

        rst.append(PERM_TO_LONG[c])

    if not lower:
        rst = [x.upper() for x in rst]

    return rst


def perm_to_short(lst, lower=True):

    rst = ''

    for p in lst:
        p = p.lower()
        if p not in PERM_TO_SHORT:
            raise PermTypeError(p)

        rst += PERM_TO_SHORT[p]

    if not lower:
        rst = rst.upper()

    return rst


def make_kazoo_digest_acl(acl):

    # acl = (('xp', '123', 'cdrwa'),
    #        ('foo', 'passw', 'rw'),
    # )

    if acl is None:
        return None

    rst = []
    for name, passw, perms in acl:
        perm_dict = {p: True
                     for p in perm_to_long(perms)}
        acl_entry = security.make_digest_acl(name, passw, **perm_dict)
        rst.append(acl_entry)

    return rst


def is_backward_locking(locked_keys, key):

    locked_keys = sorted(locked_keys)
    assert key not in locked_keys, 'must not re-lock a key'

    if len(locked_keys) == 0:
        is_backward = False
    else:
        is_backward = key < locked_keys[-1]

    return is_backward
